import os
import sys
import random
import statistics
import subprocess
import multiprocessing
from joblib import Parallel, delayed

num_cores = multiprocessing.cpu_count()

# Input raw delta value from iqtree
raw_delta_value = (4472-3671)/(4472+3671)

# Number of bootstrap replicates
num_replicates = 2000

# File containing species tree estimated from concatenated single locus sequence alignments
species_tree = ""

# File containing single locus trees in newick format generated by iqtree
single_locus_trees_file = ""

root_dir = ""

# Directory containing fasta sequence alignments. 
alignment_dir = ""

# Directory 
bootstrap_dir = root_dir + "bootstrap/"
make_bootstrap_dir = "mkdir -p {}".format(bootstrap_dir)
os.system(make_bootstrap_dir)

def get_tree_list():
	tree_list = open(single_locus_trees_file,"r").read().splitlines()
	return tree_list

def get_random_tree(tree_list):
	random_number = random.randint(0,len(tree_list)-1)
	random_tree = tree_list[random_number]
	return random_tree

def create_pseudoreplicate(number, tree_list):
	resampled_single_locus_trees_file = open("replicate_" + str(number),"a")
	for n in range(0, len(tree_list)-1):
		random_tree = get_random_tree(tree_list)
		resampled_single_locus_trees_file.write(random_tree + "\n")
	resampled_single_locus_trees_file.close()

def get_replicate_file_paths():
	os.system('find $PWD -type f -name "*replicate*" > file_paths')
	replicate_files = open("file_paths","r").read().splitlines()
	os.system("rm file_paths")
	return replicate_files

def run_gcf(single_locus_trees_file):
	run_gcf = "iqtree -t {} --gcf {} -p {} --prefix {}".format(species,tree, single_locus_trees_file, alignment_dir,single_locus_trees_file)
	os.system(run_gcf)

def clean_up_gcf_output():
	os.system("rm *.cf.branch")
	os.system("rm *.cf.tree")
	os.system("rm *.cf.tree.nex")
	os.system("rm *.log")
	
def get_stat_files_paths():
	os.system('find "$(pwd)" -name "*.cf.stat" -type f > stat_paths_file')
	stat_files_paths = open("stat_paths_file","r").read().splitlines()
	os.system("rm stat_paths_file")
	return stat_files_paths

def parse_gcf(stat_file):
	stat_line = open(stat_file,"r").read().splitlines()[18]
	# Droe-pal trees, is gdf2 in iqtree even though it is more common, due to the way they do their NNI interchange
	gdf1 = int(stat_line.split("\t")[6])
	# Fra-pal trees, is gdf1 in iqtree even though it is less common than gdf2, due to the way NNI interchange proceeds
	gdf2 = int(stat_line.split("\t")[4])
	# Figure out less hacky way to ensure that gdf1 
	delta = (gdf1-gdf2)/(gdf1+gdf2)
	return delta

def create_delta_value_list(stat_files):
	delta_value_list =[]
	for stat_file in stat_files:
		delta_value_list.append(parse_gcf(stat_file))
	return delta_value_list

def generate_output(delta_value_list):
	z_score = str((raw_delta_value)/(statistics.stdev(delta_value_list)))
	result_file = open("bootstrap_delta_results.txt","a")
	result_file.write("Raw Delta: " + str(raw_delta_value))
	result_file.write("Number of bootstrap replicates: " + str(len(delta_value_list)))
	result_file.write("Mean Delta: " + str(statistics.mean(delta_value_list)))
	result_file.write("Standard Deviation Delta: " + str(statistics.stdev(delta_value_list)))
	result_file.write("Z score for Delta: " + z_score)
	result_file.close()

def main():
	tree_list = get_tree_list()
	os.chdir(bootstrap_dir)
	Parallel(n_jobs=num_cores)(delayed(create_pseudoreplicate)(i,tree_list) for i in range(1, num_replicates + 1))

	replicate_files_list = get_replicate_file_paths()
	Parallel(n_jobs=num_cores)(delayed(run_gcf)(replicate_single_locus_trees_file) for replicate_single_locus_trees_file in replicate_files_list)
	
	clean_up_gcf_output()

	stat_files = get_stat_files_paths()

	delta_value_list = create_delta_value_list(stat_files)

	os.chdir(root_dir)
	generate_output(delta_value_list)

if __name__ == "__main__":
        main()
